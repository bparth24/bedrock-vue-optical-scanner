<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Camera Component Test</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    
    .test-container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .camera-wrapper {
      width: 100%;
      height: 400px;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      margin: 20px 0;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }
    
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .status {
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="test-container">
      <h1>CameraVideoComponent Test</h1>
      
      <!-- Status Display -->
      <div v-if="status.message" :class="['status', status.type]">
        {{ status.message }}
      </div>
      
      <!-- Camera Component -->
      <div class="camera-wrapper">
        <camera-video-component
          ref="cameraComponent"
          :auto-start="false"
          @stream-ready="onStreamReady"
          @camera-error="onCameraError"
          @capabilities-detected="onCapabilitiesDetected"
          @device-list-ready="onDeviceListReady"
          @stream-stopped="onStreamStopped" />
      </div>
      
      <!-- Controls -->
      <div class="controls">
        <button @click="startCamera" :disabled="loading">
          {{ loading ? 'Starting...' : 'Start Camera' }}
        </button>
        <button @click="stopCamera" :disabled="!streamActive">
          Stop Camera
        </button>
        <button @click="captureFrame" :disabled="!streamActive">
          Capture Frame
        </button>
      </div>
      
      <!-- Info Display -->
      <div v-if="capabilities">
        <h3>Camera Capabilities:</h3>
        <ul>
          <li>Torch: {{ capabilities.torch ? 'Yes' : 'No' }}</li>
          <li>Zoom: {{ capabilities.zoom ? 'Yes' : 'No' }}</li>
        </ul>
      </div>
      
      <div v-if="devices.length > 0">
        <h3>Available Cameras ({{ devices.length }}):</h3>
        <ul>
          <li v-for="device in devices" :key="device.deviceId">
            {{ device.label || 'Camera ' + device.deviceId.slice(0, 8) }}
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script type="module">
    // Import your CameraVideoComponent here
    // For now, we'll create a mock component for testing
    
    const CameraVideoComponent = {
      name: 'CameraVideoComponent',
      template: `
        <div class="mock-camera">
          <div v-if="!streamActive" class="mock-placeholder">
            ðŸ“· Camera will appear here
            <br><small>Click "Start Camera" to begin</small>
          </div>
          <video v-else ref="video" autoplay playsinline muted style="width: 100%; height: 100%; object-fit: cover;"></video>
        </div>
      `,
      emits: ['stream-ready', 'camera-error', 'capabilities-detected', 'device-list-ready', 'stream-stopped'],
      data() {
        return {
          streamActive: false
        };
      },
      methods: {
        async startCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: 'environment' }
            });
            
            if (this.$refs.video) {
              this.$refs.video.srcObject = stream;
            }
            
            this.streamActive = true;
            this.$emit('stream-ready', { stream, videoElement: this.$refs.video });
            this.$emit('capabilities-detected', { capabilities: { zoom: true, torch: false } });
            this.$emit('device-list-ready', { devices: [{ deviceId: 'default', label: 'Default Camera' }] });
          } catch (error) {
            this.$emit('camera-error', { error, code: error.name });
          }
        },
        
        stopCamera() {
          if (this.$refs.video && this.$refs.video.srcObject) {
            this.$refs.video.srcObject.getTracks().forEach(track => track.stop());
            this.$refs.video.srcObject = null;
          }
          this.streamActive = false;
          this.$emit('stream-stopped');
        },
        
        async captureFrame() {
          if (!this.$refs.video) return null;
          
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = this.$refs.video.videoWidth;
          canvas.height = this.$refs.video.videoHeight;
          ctx.drawImage(this.$refs.video, 0, 0);
          
          return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/jpeg', 0.8);
          });
        }
      },
      style: `
        .mock-camera {
          width: 100%;
          height: 100%;
          background: #333;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          text-align: center;
        }
        .mock-placeholder {
          font-size: 18px;
        }
      `
    };

    const { createApp } = Vue;

    createApp({
      components: {
        CameraVideoComponent
      },
      data() {
        return {
          streamActive: false,
          loading: false,
          capabilities: null,
          devices: [],
          status: { message: '', type: '' }
        };
      },
      methods: {
        async startCamera() {
          this.loading = true;
          this.setStatus('Starting camera...', 'info');
          
          try {
            await this.$refs.cameraComponent.startCamera();
          } catch (error) {
            this.setStatus(`Failed to start camera: ${error.message}`, 'error');
          } finally {
            this.loading = false;
          }
        },
        
        stopCamera() {
          this.$refs.cameraComponent.stopCamera();
          this.setStatus('Camera stopped', 'info');
        },
        
        async captureFrame() {
          try {
            const blob = await this.$refs.cameraComponent.captureFrame();
            this.setStatus(`Frame captured (${blob.size} bytes)`, 'success');
            
            // Optional: Download the captured frame
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `capture-${Date.now()}.jpg`;
            a.click();
            URL.revokeObjectURL(url);
          } catch (error) {
            this.setStatus(`Capture failed: ${error.message}`, 'error');
          }
        },
        
        onStreamReady(data) {
          this.streamActive = true;
          this.setStatus('Camera started successfully!', 'success');
        },
        
        onCameraError(data) {
          this.streamActive = false;
          this.setStatus(`Camera error: ${data.error.message}`, 'error');
        },
        
        onCapabilitiesDetected(data) {
          this.capabilities = data.capabilities;
        },
        
        onDeviceListReady(data) {
          this.devices = data.devices;
        },
        
        onStreamStopped() {
          this.streamActive = false;
        },
        
        setStatus(message, type) {
          this.status = { message, type };
          
          // Auto-clear success/info messages after 3 seconds
          if (type !== 'error') {
            setTimeout(() => {
              if (this.status.message === message) {
                this.status = { message: '', type: '' };
              }
            }, 3000);
          }
        }
      }
    }).mount('#app');
  </script>
</body>
</html>